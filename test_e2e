#!/usr/bin/env python3
import argparse
import contextlib
import glob
import os
import subprocess
import sys


class TestRunner:
    def __init__(self):
        self.tests_run = 0
        self.tests_failed = 0
        self.tests_skipped = 0

    def run(self, *, pattern=None):
        for path in sorted(glob.glob("tests/**/*.vn", recursive=True)):
            if pattern is not None and pattern not in path:
                self.tests_skipped += 1
                continue

            self.check_path(path)

    def check_path(self, path):
        print(path, end="")
        expected_output, expect_failure, should_skip = self.get_expected_output(path)
        if should_skip:
            print(f" - {text_yellow('SKIPPED')}")
            self.tests_skipped += 1
            return

        subcommand = "compile" if expect_failure else "execute"
        result = subprocess.run(
            ["./venice", subcommand, path],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            encoding="utf8",
        )

        if expect_failure:
            if expected_output and expected_output != result.stderr.rstrip("\n"):
                passed = False
            else:
                passed = result.returncode != 0
        else:
            if expected_output and expected_output != result.stdout.rstrip("\n"):
                passed = False
            else:
                passed = result.returncode == 0

        self.tests_run += 1
        if not passed:
            print(f" - {text_red('FAILED')}")
            print("--- STDERR ---")
            print(result.stderr, end="")
            print("---  END   ---")
            print()
            self.tests_failed += 1
        else:
            print()

        # Remove the bytecode file when done.
        with contextlib.suppress(FileNotFoundError):
            os.remove(path + "b")

    def get_expected_output(self, path):
        output_builder = []
        expect_failure = False
        in_output = False
        seen_output = False
        with open(path, "r", encoding="utf8") as f:
            for line in f:
                line = line.strip()
                if line.startswith("#"):
                    if line == "# FAIL":
                        expect_failure = True
                    elif line == "# SKIP":
                        return None, None, True
                    elif line == "# OUTPUT":
                        in_output = True
                        seen_output = True
                    elif line == "# END OUTPUT":
                        in_output = False
                    else:
                        if in_output:
                            line = line[1:].lstrip()
                            output_builder.append(line)
                else:
                    break

        if not expect_failure and (not seen_output or in_output):
            raise Exception(f"could not parse expected output for {path}")

        output = "\n".join(output_builder)
        return output, expect_failure, False


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "pattern",
        default="",
        nargs="?",
        help="Only run tests whose name contains the given substring",
    )
    args = parser.parse_args()

    print("=== Building Venice binaries ===")
    result = subprocess.run(["go", "build"])
    if result.returncode != 0:
        sys.exit(1)
    else:
        print("Build succeeded.")

    print()
    print()
    print("=== Running tests ===")
    test_runner = TestRunner()
    test_runner.run(pattern=args.pattern)

    total = test_runner.tests_run
    failures = test_runner.tests_failed
    skipped = test_runner.tests_skipped

    if total == 0:
        print("No tests found.")
        sys.exit(2)

    print()
    failures = test_runner.tests_failed
    if failures > 0:
        print(f"Tests {text_red('FAILED')}: {failures} failure(s)!")
        sys.exit(3)
    else:
        print(f"Tests passed. Ran {total} test(s). Skipped {skipped}.")
        sys.exit(0)


def text_red(text):
    return text_colored(text, COLOR_RED)


def text_yellow(text):
    return text_colored(text, COLOR_YELLOW)


def text_colored(text, color):
    return f"\033[{color}m{text}\033[0m"


COLOR_RED = 31
COLOR_YELLOW = 33


if __name__ == "__main__":
    main()
